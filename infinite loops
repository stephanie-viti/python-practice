def print_range(start, end):
    n = start
    while n <= end:
        print(n)
        n += 1   # ESTO es lo que rompe el ciclo

print_range(1, 5)

multiplier = 1
result = multiplier * 5
while result <= 50:
    print(result)
    multiplier += 1 #esto es lo que rompe el ciclo
    result = multiplier * 5
print("Done")
#output:
#5
#10
#15
#20
#25
#30
#35
#40
#45
#50
#Done

def addition_table(given_number):
	iterated_number = 1
	my_sum = 1
  while iterated_number <= 5:
    my_sum = given_number + iterated_number
    if my_sum > 20:
      break #rompe el ciclo
    print(str(given_number), "+", str(iterated_number), "=", str(my_sum))
    iterated_number += 1
addition_table(5)
addition_table(17)
addition_table(30)

# Expected output:
# 5 + 1 = 6
# 5 + 2 = 7
# 5 + 3 = 8
# 5 + 4 = 9
# 5 + 5 = 10
# 17 + 1 = 18
# 17 + 2 = 19
# 17 + 3 = 20
# None

def is_power_of_two(number):
  # This while loop checks if the "number" can be divided by two
  # without leaving a remainder. How can you change the while loop to
  # avoid a Python ZeroDivisionError?
  while number > 1 and number % 2 == 0: # esto se evalua hasta que la condicion deje de ser verdadera entonces entra al if
    number = number / 2
  # If after dividing by 2 "number" equals 1, then "number" is a power
  # of 2.
  if number == 1:
    return True
  return False
  
# Calls to the function
print(is_power_of_two(0)) # Should be False
print(is_power_of_two(1)) # Should be True
print(is_power_of_two(8)) # Should be True
print(is_power_of_two(9)) # Should be False
